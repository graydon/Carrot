(= (id a a) x x)

;;bool
(= (true Bool)  t e t)
(= (false Bool) t e e)
(= (not Bool Bool)
   bool (bool false true))
(= (if Bool a a a) bool bool) ;point-free

;;function
(= (comp (Fn b c) (Fn a b) a c)
   f g x (f (g x)))
(= (compose (Fn b c) (Fn a b) a c) comp)
(= (flip (Fn a b c) b a c)
   f x y (f y x))

(= (/> a (Fn a b) b)
   x f (f x))
(= (-> a (Fn b c) (Fn a b) c)
   x f g (f (g x)))
;;e.g. (-> 2 -> (+ 1) -> (+ 4) -> (+ 3) id (+ 6))


;;list
(= (cons a (List a) (List a))
   head tail f (f head tail))
(= (car (List a) a)
   xs (xs true))
(= (cdr (List a) (List a))
   xs (xs false))
(= (nil a (List a)) 'nil)
(= (nil? a Bool) (=? nil))

;;tuple
(= (2-tuple a b (Tuple a b)) cons)
(= (fst (Tuple a b) a) car)
(= (snd (Tuple a b) b) cdr)

;;Y-combinator
;;(= (Y (Fn a a) a) x (x (Y x)))
;;(Y (^ (f) f)) ;now f refers to the function itself
(= (Y (Fn a a) a)
   f ((^ x (f (x x))) (^ x (f (x x)))))

;;show
(= (show String String)
   x x)
(= (show Number String)
   x (num->str x))
(= (show (List a) String)
   xs
   (nil? xs "nil"
         (++ (show (car xs)) (++ "," (show (cdr xs))))))


;;primitive wrapper
(= (=? a b Bool)
   a b (** =? a b))
(= (< Number Number Bool)
   a b (** lt? a b))
(= (> Number Number Bool)
   a b (** gt? a b))
(= (<= Number Number Bool)
   a b (** lte? a b))
(= (>= Number Number Bool)
   a b (** gte? a b))
(= (+ Number Number Number)
   a b (** add a b))
(= (- Number Number Number)
   a b (** sub a b))
(= (* Number Number Number)
   a b (** mul a b))
(= (/ Number Number Number)
   a b (** div a b))
(= (% Number Number Number)
   a b (** mo a b))
(= (++ String String String)
   a b (** ++ a b))
(= (num->str Number String)
   a (** num->str a))
(= (number? a Bool)
   a (** num? a))
(= (string? a Bool)
   a (** str? a))
(= (print Time String Time)
   time str (** timed-print time str))
(= (read Time (Tuple Time String))
   time (cons (+ time 1) (** read)))

;;help
(= (help String)
"SYNTAX:\n\
(= name parameter ... expression) ;(statement) binds a function to a name\n\
(^ parameter ... expression)      ;(expression) lambda expression\n\
(** primitive-name argument ...)     ;(expression) call a primitive function. Most of them are abstructed so you rarely have to use this syntax\n\
(function-name argument ...)         ;(expression) apply a function to values
\"string\"                             ;(expression)\n\
number                               ;(expression)\n\
'symbol                              ;(expression)\n\n\
FEATURE:\n\
* Default lazy evaluation\n\
* Automatic currying\n\n\
REPL:\n\
^C to exit\n\
help to see this help")
