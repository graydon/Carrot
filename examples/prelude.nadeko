(= id x x)

;;bool
(= true  t e t)
(= false t e e)
(= not bool
  (bool false true))
(= if bool bool) ;point-free

;;function
(= comp f g x (f (g x)))
(= compose comp)
(= apply f lst
   (nil? lst f (apply (f (car lst)) (cdr lst))))
(= flip f x y (f y x))

(= /> x f (f x))
(= -> x f g (f (g x)))
;;e.g. (-> 2 -> (+ 1) -> (+ 4) -> (+ 3) id (+ 6))

(= pipe xs
   (nil? xs id
         (comp (pipe (cdr xs)) (car xs))))


;;list
(= cons head tail f (f head tail))
(= car lst (lst (^ h t h)))
(= cdr lst (lst (^ h t t)))
(= nil 'nil)
(= nil? (=? nil))
(= o- x f y (cons x (f y)))

;;tuple
(= 2-tuple cons)
(= fst car)
(= snd cdr)

;;Y-combinator
;;(Y (^ (f) f)) ;now f refers to the function itself
(= Y f ((^ x (f (x x))) (^ x (f (x x)))))

;;show
(= show a
  (string? a a
  (number? a (num->str a)
  (nil? a "nil"
  (++ (++ (show (car a)) ", ") (show (cdr a)))))))

;;primitive wrapper
(= =?  a b (** =? a b))
(= <   a b (** lt? a b))
(= >   a b (** gt? b a))
(= <=  a b (** lte? a b))
(= >=  a b (** gte? b a))
(= +   a b (** add a b))
(= -   a b (** sub a b))
(= *   a b (** mul a b))
(= /   a b (** div a b))
(= %   a b (** mo a b))
(= ++  a b (** ++ a b))
(= num->str a (** num->str a))
(= number?  a (** num? a))
(= string?  a (** str? a))
(= print time str (** timed-print time str))
(= read  time (cons (+ time 1) (** read)))

;;help
(= help "SYNTAX:\n\
(= name parameter ... expression) ;(statement) binds a function to a name\n\
(^ parameter ... expression)      ;(expression) lambda expression\n\
(** primitive-name argument ...)     ;(expression) call a primitive function. Most of them are abstructed so you rarely have to use this syntax\n\
(function-name argument ...)         ;(expression) apply a function to values
\"string\"                             ;(expression)\n\
number                               ;(expression)\n\
'symbol                              ;(expression)\n\n\
FEATURE:\n\
* Default lazy evaluation\n\
* Automatic currying\n\n\
REPL:\n\
^C to exit\n\
help to see this help")
